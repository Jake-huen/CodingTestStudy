[10, 20, 10, 30, 20, 50] 이라는 수열이 있을 때, 오름차순으로 증가하는 부분 수열 중 가장 길이가 긴 수열을 의미합니다.

여기서는 [10,20,30,50]이 가장 긴 증가하는 부분수열이고, 길이는 4입니다.

## DP

dp를 이용한 방법은 수열의 값을 하나씩 비교하기 때문에 시간 복잡도가 O(n^2)입니다.


```python
n = int(input())  # 수열의 길이
array = list(map(int, input().split()))  # 주어진 수열

# DP 테이블 1로 초기화
dp = [1] * n

for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

# 가장 긴 증가하는 부분 수열의 길이값
result = max(dp)
print(result)
```


## Binary Search

이분 탐색을 이용한 방법은 모든 수열의 값을 일일이 비교하지 않아도 되기 때문에 시간 복잡도가 O(nlogn)입니다.

이분 탐색으로 할 때는 x와 dp 두가지가 필요합니다.

```python
from bisect import bisect_left

array = [5, 2, 1, 4, 3, 5]
dp = [1]
x = [array[0]]

for i in range(1, len(array)):
    if array[i] > x[-1]: # 현재 값이 x 배열의 마지막 값보다 클 경우
        x.append(array[i]) # x 배열에 현재 값을 추가해 주고
        dp.append(dp[-1] + 1) # 증가 부분 수열의 길이를 1 증가시킨다.
    else: # 그렇지 않을 경우
        idx = bisect_left(x, array[i]) # 현재 값이 x 배열의 몇 번째 인덱스에 들어갈 수 있는지를 찾아서
        x[idx] = array[i] # x 배열의 idx 위치에 현재 값을 넣어준다.
```


`lines = [3, 10, 2, 1, 20]`


LIS의 길이를 유지하면서 가능한한 작은 값들을 넣습니다. => 최적의 위치를 찾을 수 있습니다.

- **왜 삽입 위치를 업데이트하나요?**
    - `x` 리스트는 실제 LIS가 아니라, 가능한 작은 값들로 구성된 리스트입니다. 이렇게 하면 더 긴 LIS를 찾기 쉽게 됩니다.
    - 예를 들어, 2가 들어갈 위치에 3이 있었다면, 2로 업데이트함으로써 이후에 더 작은 값들을 처리할 수 있게 됩니다. 이것은 `x` 리스트를 가능한 작은 값들로 유지하여, 더 긴 증가 수열을 쉽게 찾도록 도와줍니다.

1. **초기화**

    - `dp = [1]`
    - `x = [3]`
2. **두 번째 원소 (10) 처리**

    - 10 > 3 (`x`의 마지막 원소)
    - `x`에 10 추가: `x = [3, 10]`
    - `dp`에 2 추가: `dp = [1, 2]`
3. **세 번째 원소 (2) 처리**

    - 2 <= 10 (`x`의 마지막 원소)
    - `bisect_left(x, 2)`를 사용하여 2가 삽입될 위치를 찾음: `idx = 0`
    - `x`의 `idx` 위치를 2로 갱신: `x = [2, 10]`

   여기서 `x` 리스트는 실제 LIS가 아니지만, LIS의 길이를 유지하면서 가능한 작은 값들로 구성되어 있으므로 최적의 결과를 얻을 수 있습니다.

4. **네 번째 원소 (1) 처리**

    - 1 <= 10 (`x`의 마지막 원소)
    - `bisect_left(x, 1)`를 사용하여 1이 삽입될 위치를 찾음: `idx = 0`
    - `x`의 `idx` 위치를 1로 갱신: `x = [1, 10]`
5. **다섯 번째 원소 (20) 처리**

    - 20 > 10 (`x`의 마지막 원소)
    - `x`에 20 추가: `x = [1, 10, 20]`
    - `dp`에 3 추가: `dp = [1, 2, 3]`